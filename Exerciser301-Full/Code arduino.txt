if (msg == "ON") {
      digitalWrite(LED_PIN, HIGH);
      ledState = true;
      Serial.println("üí° LED B·∫¨T");
    } else if (msg == "OFF") {
      digitalWrite(LED_PIN, LOW);
      ledState = false;
      Serial.println("üí° LED T·∫ÆT");
    }
  }
  else if (String(topic) == TOPIC_MOTOR) {
    int val = msg.toInt();
    motorState = val;
    motorControl(val);
  }
}

// =====================================================
void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  pinMode(MOTOR_A1, OUTPUT);
  pinMode(MOTOR_A2, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  motorControl(0);
  dht.begin();

  Serial.printf("üì° WiFi: %s\n", ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\n‚úÖ WiFi connected!");
  Serial.print("üì∂ IP: ");
  Serial.println(WiFi.localIP());

  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);
  sendTelegram("üöÄ ESP32 ƒë√£ kh·ªüi ƒë·ªông v√† k·∫øt n·ªëi WiFi th√†nh c√¥ng!");
}

// =====================================================
void loop() {
  if (!client.connected()) reconnect();
  client.loop();

  unsigned long now = millis();
  if (now - lastSensorTime > 5000) {
    lastSensorTime = now;
    float h = dht.readHumidity();
    float t = dht.readTemperature();

    if (!isnan(h) && !isnan(t)) {
      String payload = "{\"temp\":" + String(t, 1) + ",\"humi\":" + String(h, 1) + "}";
      client.publish(TOPIC_SENSOR, payload.c_str());
      Serial.printf("üì§ G·ª≠i d·ªØ li·ªáu ‚Üí %s: %s\n", TOPIC_SENSOR, payload.c_str());

      // === Ki·ªÉm tra ng∆∞·ª°ng nhi·ªát ƒë·ªô ===
      if (t > 30.0 && !overheatAlertSent) {
        String alert = "üî• C·∫£nh b√°o: Nhi·ªát ƒë·ªô cao (" + String(t, 1) + "¬∞C)";
        sendTelegram(alert);
        overheatAlertSent = true;
      }
      else if (t <= 30.0 && overheatAlertSent) {
        sendTelegram("‚úÖ Nhi·ªát ƒë·ªô ƒë√£ tr·ªü l·∫°i b√¨nh th∆∞·ªùng (" + String(t, 1) + "¬∞C)");
        overheatAlertSent = false;
      }

    } else {
      Serial.println("‚ö†Ô∏è L·ªói ƒë·ªçc c·∫£m bi·∫øn DHT22");
    }
  }
}
#include <WiFi.h>
#include <PubSubClient.h>
#include <HTTPClient.h>
#include <DHT.h>

// ==== WIFI & MQTT ====
const char* ssid = "TDMU-Luxury";
const char* password = "12346789";
const char* mqtt_server = "192.168.43.151";

// ==== TELEGRAM ====
String BOT_TOKEN = "8216743624:AAGsDrbQf0oXVoHjqtqBVyvPt-b-jt4zCdM";
String CHAT_ID   = "6329782688";
String TELEGRAM_URL = "https://api.telegram.org/bot" + BOT_TOKEN + "/sendMessage";

// ==== PIN ====
#define LED_PIN 3      
#define MOTOR_A1 8     
#define MOTOR_A2 9     
#define DHT_PIN 5    
#define DHT_TYPE DHT22

WiFiClient espClient;
PubSubClient client(espClient);
DHT dht(DHT_PIN, DHT_TYPE);

// ==== TOPIC ====
#define TOPIC_LED "/esp32/led/led"
#define TOPIC_MOTOR "/esp32/motor/motor"
#define TOPIC_SENSOR "/esp32/sensor"
#define TOPIC_STATUS "/esp32/status"

// ==== TR·∫†NG TH√ÅI ====
bool ledState = false;
int motorState = 0;
unsigned long lastSensorTime = 0;
bool overheatAlertSent = false;  // ƒë√°nh d·∫•u ƒë√£ g·ª≠i c·∫£nh b√°o nhi·ªát ƒë·ªô

// =====================================================
// G·ª≠i tin nh·∫Øn Telegram
void sendTelegram(String message) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    String url = TELEGRAM_URL + "?chat_id=" + CHAT_ID + "&text=" + message;
    http.begin(url);
    int httpCode = http.GET();
    if (httpCode == 200) {
      Serial.println("üì® G·ª≠i Telegram th√†nh c√¥ng!");
    } else {
      Serial.printf("‚ö†Ô∏è L·ªói g·ª≠i Telegram: %d\n", httpCode);
    }
    http.end();
  }
}

// =====================================================
void reconnect() {
  while (!client.connected()) {
    Serial.print("üîÑ K·∫øt n·ªëi MQTT...");
    if (client.connect("ESP32_Client")) {
      Serial.println("‚úÖ OK");
      client.subscribe(TOPIC_LED);
      client.subscribe(TOPIC_MOTOR);
      client.publish(TOPIC_STATUS, "ONLINE"); // g·ª≠i tr·∫°ng th√°i khi k·∫øt n·ªëi l·∫°i
      sendTelegram("‚úÖ ESP32 ƒë√£ k·∫øt n·ªëi MQTT (ONLINE)");
    } else {
      Serial.print("‚ùå L·ªói MQTT rc=");
      Serial.println(client.state());
      client.publish(TOPIC_STATUS, "OFFLINE"); // g·ª≠i tr·∫°ng th√°i l·ªói
      delay(3000);
    }
  }
}

// =====================================================
void motorControl(int state) {
  if (state == 1) {
    digitalWrite(MOTOR_A1, HIGH);
    digitalWrite(MOTOR_A2, LOW);
    Serial.println("‚öôÔ∏è Motor: TI·∫æN");
  } 
  else if (state == -1) {
    digitalWrite(MOTOR_A1, LOW);
    digitalWrite(MOTOR_A2, HIGH);
    Serial.println("‚öôÔ∏è Motor: L√ôI");
  } 
  else {
    digitalWrite(MOTOR_A1, LOW);
    digitalWrite(MOTOR_A2, LOW);
    Serial.println("‚öôÔ∏è Motor: D·ª™NG");
  }
}

// =====================================================
void callback(char* topic, byte* payload, unsigned int length) {
  String msg = "";
  for (unsigned int i = 0; i < length; i++) msg += (char)payload[i];
  Serial.printf("üì© [%s]: %s\n", topic, msg.c_str());

  if (String(topic) == TOPIC_LED) {